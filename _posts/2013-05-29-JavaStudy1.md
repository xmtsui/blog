---
layout: post
title: Java随笔1
categories:
- Java
---
实现`java.util.*`有关private static内部类的一点经验
最近碰到个不大不小的问题。花了点时间来分析了一下。

jdk里LinkedList中的实现，把节点定义成
`private static class Node<E>`
定义成内部类，private都比较好理解，然而为何定义成static的呢？

好几个地方发帖子问了，都没得到想要的答案，只有自己动手了。我最后的结论也很没用，不过这个学习的过程我觉得可以记一下。结论是定义成static的出发点是方便调用，从oop设计的角度上条理清晰。  

下面分析一下我得出结论的过程  
首先看下内部类的好处有：  
__可以访问外部类的私有属性或方法，或者构造函数__

特点（这个根据不同的情景不一定是缺点）  
1. 必须依附外部类实例才能实例化（静态内部类没有这个特点）  
2. 但LinkedList里面对`Node<E>又加上private`修饰，所以不可能在外部使用。所以这一点在这意义也不大。

在我看来，此处的`Node<E>`等同于一个外部顶层类。但考虑到是泛型, 封装的因素，所以定义成了内部类。static是仅仅是不想在util库里莫名其妙的多一个类出来，因为该节点类只有linkedlist使用。是不是static，在本类的使用上没有影响。因为即便是non static，在节点定义的时候外部链表类也早已实例化。

这个结论从下面stackoverflow的回答也得以确认
sun官方page说：
> Note: A static nested class interacts with the instance members of its outer class (and other classes) just like any other top-level class. In effect, a static nested class is behaviorally a top-level class that has been nested in another top-level class for packaging convenience.  
> A nested class is a member of its enclosing class. Non-static nested classes (inner classes) have access to other members of the enclosing class, even if they are declared private. Static nested classes do not have access to other members of the enclosing class.

如果要深入分析内存，
看到一句话：内部类是Java编译器一手操办的。虚拟机并不知道内部类与常规类有什么不同。
自己动手分析了一下，的确是。
首先实例化的节点对象都是在堆内存，而不一样的是方法区中加载类的类型信息，以及栈上的对象引用。
内部类编译后可以很容易看到，也是做为单独的类出现。当内部类被使用时，才会被加载。
类型信息的存储，以及引用的存储，不会耗费太多内存空间。
然后堆上的分配都是按需所取，也没什么异议。

而我发现的**唯一不同**是：
如果私有内部类没有显示声明构造函数，编译后会生成一个｛内部类类名$1.class｝的文件
这个通过反编译可以看到是一个空类
用处是产生一个包可见构造函数，如下：

----  

｛外部类类名$内部类类名(外部类类名, 外部类类名$1);｝

----  
这个构造函数可以确保内部类的private特性 －－ 不能从外部其他类实例化
这个编译器优化策略类似于java条件编译，也是一种语法糖。即只有在外部类明确分配内部类的内存时，才会产生这个构造函数。仅仅声明引用的话，不会生成这个构造函数。
同样，针对外部类的private变量，如果在内部类中明确使用了，才会在外部类编译时加上一个static的访问函数：
static int access$100();


参考链接：  
<http://stackoverflow.com/questions/253492/static-nested-class-in-java-why>  
<http://hxraid.iteye.com/blog/494230>  
<http://stackoverflow.com/questions/6223093/when-would-i-want-to-make-my-private-class-static>